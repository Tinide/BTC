### 钱包
钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。

从程序员的角度来看，“钱包”是指用于存储和管理用户密钥的数据结构。 

深入介绍第二层含义
本节课中钱包是私钥的容器，一般是通过结构化文件或简单数据库来实现。

“比特币”被记录在比特币网络的区块链中。用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。

钱包只包含私钥/公钥对的密钥链。

有两种主要类型的钱包，区别在于它们包含的多个密钥是否相互关联。

**第一种类型是非确定性钱包（nondeterministic wallet）**

每个密钥都是从随机数独立生成的。密钥彼此无关。

**第二种类型是确定性钱包（deterministic wallet）**

所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。

如果有原始种子，则可以再次生成全部密钥。

确定性钱包中使用了许多不同的密钥推导方法。
最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。

确定性钱包由种子衍生创造。为了便于使用，**种子被编码为英文单词，也称为助记词。**

#### 非确定性（随机）钱包
钱包只是随机生成的私钥集合。

用法：举个例子，比 特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每个密钥只使用一次。

缺点：难以管理、 备份以及导入。

图5-1展示的是一个非确定性钱包，其含有的随机密钥是个松散的集合。

![图5-1表示包含有松散结构的随机钥匙的集合的非确定性钱包](http://upload-images.jianshu.io/upload_images/1785959-77bbcea7174071c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 确定性（种子）钱包

确定性，或者“种子”钱包包含通过使用**单项离散函数**而可从**公共的种子**生成的私钥。**种子是随机生成的数字。**

这个数字也含有比如索引号码或者可生成私钥的“链码”。

图5-2展示了确定性钱包的逻辑图。

![图5-2确定性种子钱包：从种子派生的密钥的确定性序列](http://upload-images.jianshu.io/upload_images/1785959-be390ca284ed5f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###  分层确定性钱包（HD Wallets (BIP-32/BIP-44)）



图5-3展示了树状结构。

![图5-3HD钱包:从种子产生的密钥树](http://upload-images.jianshu.io/upload_images/1785959-7ce3000da8239b74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

HD钱包有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。可以被用在企业环境中。

HD钱包的第二个好处是，**用户可以创建一系列公钥，而不需要访问对应的私钥**。

### 钱包最佳实践

这些常用的标准是：

助记码，基于BIP-39

HD钱包，基于BIP-32

多用途HD钱包结构，基于BIP-43

多币种和多帐户钱包，基于BIP-44

#### 使用比特币钱包

Trezor比特币硬件钱包

### 钱包技术细节
#### 助记码词汇（BIP-39）

助记码词汇是英文单词序列代表（编码）用作种子对应所确定性钱包的随机数。
并且从种子那里重新创造钱包以及所有私钥。

在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。单词的顺序就是钱包的备份。它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的密钥。

#### 1-6步是创建助记词，7-9步是从助记词到种子。

图5-6展示了熵如何生成助记词。

![图5-6表示生成熵和编码作为助记词](http://upload-images.jianshu.io/upload_images/1785959-bed496243dd75389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。钱包从熵源开始，增加校验和，然后将熵映射到单词列表：

1、创建一个128到256位的随机序列（熵）。

2、提出SHA256哈希前几位（熵长/32），就可以创造一个随机序列的校验和。

3、将校验和添加到随机序列的末尾。

4、将序列划分为包含11位的不同部分。

5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。

6、生成的有顺序的单词组就是助记码。

#### 从助记词生成种子

**助记词表示长度为128至256位的熵。通过使用密钥延伸函数PBKDF2，熵被用于导出较长的（512位）种子。将所得的种子用于构建确定性钱包并得到其密钥。**

密钥延伸函数有两个参数：助记词和盐。其中盐的目的是增加构建能够进行暴力攻击的查找表的困难度。


图5-7显示了从助记词如何生成种子
![图5-7显示了从助记词如何生成种子](http://upload-images.jianshu.io/upload_images/1785959-155e604188878b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


创建助记词之后的7-9步是：

#### PBKDF2密钥延伸函数

密钥延伸函数，使用2048次哈希是一种非常有效的保护，可以防止对助记词或密码短语的暴力攻击。它使得攻击尝试非常昂贵（从计算的角度），需要尝试超过几千个密码和助记符组合，而这样可能产生的种子的数量是巨大的（2^512）

7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。

8、PBKDF2密钥延伸函数的第二个参数是盐。由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。

9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。这个512位的值就是种子。

#### BIP-39中的可选密码短语

BIP-39标准允许在推导种子时使用可选的密码短语。如果没有使用密码短语，助记词是用由常量字符串“助记词”构成的盐进行延伸，从任何给定的助记词产生一个特定的512位种子。如果使用密码短语，密钥延伸函数使用同样的助记词也会产生不同的种子。事实上，给予一个单一的助记词，每一个可能的密码短语都会导致不同的种子。基本上没有“错误”的密码短语，所有密码短语都是有效的，它们都会导致不同的种子，形成一大批可能未初始化的钱包。


可选密码短语带来两个重要功能：
（存储在大脑中的）密码短语成为第二个因素，使得助记词不能单独使用，避免了助记词备份盗取后被利用。
起到掩人耳目的效果，把密码短语指向有小额资金的钱包，分散攻击者注意力，使其不在关注拥有大额资金的“真实”钱包。

使用助记符代码

BIP-39被做成函数库，支持多种编程语言

BIP-39生成器可以离线使用，也可以使用[这个在线地址](https://dcpos.github.io/bip39/).地址转向到[这儿了](https://iancoleman.github.io/bip39/)。

### 从种子中创造HD钱包

HD钱包从单个根种子（root seed）中创建，为128到256位的随机数。最常见的是，这个种子是从助记符产生的


HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。

图5-9展示创建主密钥以及HD钱包的主链代码的过程。

![图5-9从根种子创建主密钥以及HD钱包的主链代码的过程](http://upload-images.jianshu.io/upload_images/1785959-838fb4445a1d179c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m)（master private key(m) ）和主链代码（a master chain code）的哈希。主私钥（m）之后可以通过使用我们先前看到的那个普通椭圆曲线m * G过程生来成相对应的主公钥（M）。链代码用于从母密钥中创造子密钥的那个函数中引入熵。

### 私有子密钥的衍生

分层确定性钱包使用CKD（child key derivation)函数去从母密钥衍生出子密钥。


子密钥衍生函数是基于单项哈希函数。这个函数结合了：

一个母私钥或者公共钥匙（ECDSA未压缩键）

一个叫做链码（256 bits）的种子

一个索引号（32 bits）


这三个项目（母密钥，链码，索引）相结合并散列可以生成子密钥，如下。

索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）。

![图5-10延长母私钥去创造子私钥](http://upload-images.jianshu.io/upload_images/1785959-23efe345e02fa0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512函数散列之后可以产生512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。

链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。


图5-11阐述了扩展母公钥来衍生子公钥的传递机制。

![图5-11扩展母公共钥匙来创造一个子公共钥匙](http://upload-images.jianshu.io/upload_images/1785959-1224f8f1acd381d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 使用衍生的子密钥

子私钥不能从非确定性（随机）密钥中被区分出来。

因为衍生函数是单向的，所以子密钥不能被用来发现他们的母密钥。子密钥也不能用来发现他们的相同层级的姊妹密钥。

只有母密钥以及链码才能得到所有的子密钥。没有子链码的话，子密钥也不能用来衍生出任何孙密钥。你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。

提示 子私钥、对应的公钥以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包函数之外是不可见的。一旦被创造出来，它们就和“正常”密钥一样运行了。

### 扩展密钥

密钥衍生函数可以被用来创造密钥树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。

密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key）。

扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。
有两种扩展密钥。

扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公钥）。
**公钥以及链码组成扩展公钥，它可以用来扩展子公钥。**

一个扩展密钥可以创造出子密钥并且能创造出密钥树结构中的整个分支。
分享扩展密钥就可以访问整个分支。


扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP-32兼容钱包之间导入导出。扩展密钥编码用的Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check编码串更长一些。


#### 公共子密钥推导

分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从公共母密钥派生出公共子密钥的能力。这就给了我们两种衍生子公钥的方法：或者通过子私钥，再或者就是直接通过母公钥。



(密钥以及链码)扩展密钥可以在HD钱包结构的分支中，被用来衍生所有的公钥（且只有公钥）。

这种快捷方式可以用来创造非常保密的只有公钥配置。

在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。
与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。

#### 硬化子密钥的衍生

**公钥以及链码组成扩展公钥，它可以用来扩展子公钥。**

从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。
访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。

简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。

![图5-13子密钥的硬化推导;省略父公钥](http://upload-images.jianshu.io/upload_images/1785959-da0636d43b3579ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

为了应对这种风险，HD钱包使用一种叫做硬化衍生(hardened derivation）的替代衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥，如图5-13所示。

当强化私钥衍生函数被使用时，得到的子私钥以及链码与使用一般衍生函数所得到的结果完全不同。得到的密钥“分支”可以被用来生产不易被攻击的扩展公钥，因为它所含的链码不能被用来开发或者暴露任何私钥。强化衍生也因此被用在上一层级，使用扩展公钥的密钥树中创造“间隙”。

简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴露在泄露扩展链码的风险下，你应该从强化母私钥衍生公钥，而不是从一般的母私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层级的子密钥最好使用强化衍生。

#### 正常衍生和强化衍生的索引号码
为了让索引号码更容易被阅读和展示，强化子密钥的索引号码是从0开始展示的，但是右上角有一个小撇号。

第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0'。
当你看到HD钱包索引号i'，这就意味着2^31+i。

### HD钱包密钥识别符（路径）

HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示（见表5-6）。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。

密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。

![表5-6 HD钱包路径的例子](http://upload-images.jianshu.io/upload_images/1785959-4fb34b7a9b8d8df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### HD钱包树状结构的导航
HD钱包树状结构提供了极大的灵活性。
对无限的树状结构进行导航就变得异常困难。

两个比特币改进建议（BIPs）提供了这个复杂问题的解决办法——通过创建几个HD钱包树的提议标准。BIP-43提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。
基于BIP-43，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i'/是 为了表明那个被索引号“i”定义的特殊为目地。


在BIP-43标准下，为了延长的那个特殊规范，BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m/44'/。

BIP-44指定了包含5个预定义树状层级的结构：

m / purpose' / coin_type' / account' / change / address_index

第一层的purpose总是被设定为44'。

第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44'/0'、Bitcoin Testnet is m/44'/1'，以及 Litecoin is m/44'/2'。

树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。举个例子，一个HD钱包可能包含两个比特币“账户”：m/44'/0'/0' 和 m/44'/0'/1'。每个账户都是它自己亚树的根。

第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。

被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是M/44'/0'/0'/0/2。表5-7展示了更多的例子。

![表5-7 BIP0044 HD 钱包结构的例子](http://upload-images.jianshu.io/upload_images/1785959-8e9b2f2dbbc42acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)